import logging

import sqlalchemy

from almanac.DAOs.base_dao import BaseDAO
from almanac.exc.exceptions import DAOException
from almanac.models import db
from almanac.models import CustomerTable as Customer, UserTable as User
from almanac.utils.database_utils import exec_and_commit


class CustomerDAO(BaseDAO):
    """
    Handles mirroring braintree customer operations in our database.
    """

    def get_customer_by_user_id(self, user_id):
        """
        Handles retrieving a customer for the user.
        :param str user_id: The customer's UUID.
        :rtype: CustomerTable
        :return: The requested customer.
        """
        found_customer = db.session.query(
            Customer,
        ).filter(
            Customer.user_id == user_id,
        ).first()

        if found_customer is None:
            logging.error(
                'Failed to retrieve customer by User ID {0}'.format(
                    user_id,
                )
            )
            raise DAOException('Failed to retrieve selected customer.')

        return found_customer

    def get_customer_by_public_id(self, customer_public_id):
        """
        Handles retrieving a customer by it's public ID.

        :param str customer_public_id: The public ID for the customer
        :rtype: CustomerTable
        :return: The requested customer.
        """
        found_customer = db.session.query(
            Customer
        ).filter_by(
            public_id=customer_public_id
        ).first()

        if found_customer is None:
            logging.error(
                'Failed to retrieve customer by ID {0}'.format(
                    customer_public_id,
                )
            )
            raise DAOException('Failed to retrieve selected customer.')

        return found_customer

    def create_customer(self, bt_customer_id, cc_token, first_name, last_name,
                        user_id, *, is_default=False, skip_commit=False):
        """
        Handles creating a new mirrored customer in our database which
        represents the necessary information in our system. Note: these values
        also persist in Braintree.

        :param str bt_customer_id: The unique identifier generated by
        Braintree.
        :param str cc_token: A uniquely generated (by us) value for the payment
        method.
        :param str first_name: The customer's first name.
        :param str last_name: The customer's last name.
        :param str user_id: The customer's UUID.
        :param bool is_default: If we want this new payment method to be the
        default payment method.
        :rtype: CustomerTable
        :return: The newly created customer.
        """
        new_customer = Customer(
            bt_customer_id,
            cc_token,
            first_name,
            last_name,
            user_id,
            is_default=is_default
        )

        try:
            exec_and_commit(
                db.session.add,
                new_customer,
                skip_commit=skip_commit,
            )
        except Exception as e:
            logging.critical(
                'Failed to create a new customer in our database: {0} with'
                'exception of: {1}'.format(
                    new_customer,
                    e,
                )
            )
            raise DAOException(
                'Failed to create new customer.'
            )

        return new_customer

    def delete_customer(self, customer_public_id):
        """
        Handles setting a customer account as deleted. (Soft delete)

        :param str customer_public_id: The UUID identifying the customer
        account in the database.

        :rtype: CustomerTable
        :return: The recently deleted customer.
        """
        found_customer = self.get_customer_by_public_id(customer_public_id)

        db.session.query(
            Customer
        ).filter_by(
            public_id=customer_public_id,
        ).update({
            "is_deleted": True
        })

        try:
            db.session.commit()
        except sqlalchemy.exc.IntegrityError as e:
            logging.error(
                'Failed to remove customer account {0}'.format(
                    customer_public_id,
                )
            )
            raise DAOException('Failed to remove selected customer.')

        return found_customer

