from datetime import datetime
import logging
from http import HTTPStatus

import sqlalchemy

from almanac.DAOs.base_dao import BaseDAO
from almanac.DAOs.braintree.customer_dao import CustomerDAO
from almanac.exc.exceptions import DAOException
from almanac.models import db
from almanac.models import SubscriptionTable as Subscription
from almanac.utils.database_utils import exec_and_commit


class SubscriptionDAO(BaseDAO):
    """
    Handles mirroring braintree customer operations in our database.
    """
    def __init__(self):
        self.customer_dao = CustomerDAO()

    def get_subscription_by_user_id(self, user_id):
        """
        Handles retrieving a subscription for the user.

        :param str user_id: The customer's UUID.
        :rtype: SubscriptionTable
        :return: The requested subscription.
        """
        found_subscription = db.session.query(
            Subscription,
        ).filter(
            Subscription.user_id == user_id,
        ).first()

        if found_subscription is None:
            logging.error(
                'Failed to retrieve subscription by User ID {0}'.format(
                    user_id,
                )
            )
            raise DAOException('Failed to retrieve subscription info.')

        return found_subscription

    def get_subscription_by_public_id(self, subscription_public_id):
        """
        Handles retrieving a subscription by it's public ID.

        :param str subscription_public_id: The public ID for the customer
        :rtype: SubscriptionTable
        :return: The requested subscription.
        """
        found_subscription = db.session.query(
            Subscription
        ).filter_by(
            public_id=subscription_public_id
        ).first()

        if found_subscription is None:
            logging.error(
                'Failed to retrieve subscription by ID {0}'.format(
                    subscription_public_id,
                )
            )
            raise DAOException('Failed to retrieve selected subscription.')

        return found_subscription

    def create_subscription(self, bt_sub_id, user_id, *, plan_id='Basic0x01',
                            skip_commit=False):
        """
        Handles creating a subscription record in the db.


        :param str bt_sub_id: The unique identifier generated by braintree
        when subscriptions are created.
        :param str user_id: The customer's UUID.
        :param str plan_id: The plan we want to subscribe to.
        :param bool skip_commit: Handles skipping the commit to create a pseudo
        transaction.
        :rtype: SubscriptionTable
        :return: The newly created subscription
        """
        new_subscription = Subscription(
            self.customer_dao.get_customer_by_user_id(user_id).public_id,
            user_id,
            bt_sub_id,
            plan_id=plan_id,
        )

        try:
            exec_and_commit(
                db.session.add,
                new_subscription,
                skip_commit=skip_commit,
            )
        except Exception as e:
            logging.critical(
                'Failed to create a new subscription in our database: {0} with'
                'exception of: {1}'.format(
                    new_subscription,
                    e,
                )
            )
            raise DAOException(
                'Failed to create new subscription.'
            )

        return new_subscription

    def cancel_subscription(self, user_id):
        """
        Handles cancelling a subscription for the user.

        :param str user_id: The customer whom we want to cancel the
        subscription for.
        :rtype: SubscriptionTable
        :return: The recently cancelled subscription
        """
        found_subscription = self.get_subscription_by_user_id(user_id)

        if found_subscription is None:
            raise DAOException(
                'Subscription not found.',
                status_code=HTTPStatus.NOT_FOUND
            )

        db.session.query(
            Subscription
        ).filter_by(
            public_id=found_subscription.public_id,
        ).update({
            'is_deleted': True,
            'date_ended': datetime.utcnow(),
        })

        try:
            db.session.commit()
        except sqlalchemy.exc.IntegrityError as e:
            logging.error(
                'Failed to remove subscription for user {0} with '
                'exc: {1}'.format(
                    user_id,
                    e,
                )
            )
            raise DAOException('Failed to cancel subscription.')

        return found_subscription

